---
title: Unit testing a redux-saga saga
description: A method for unit testing a saga
date: 2021-02-29
faIcon: faAtom
---

# Problem

[redux-saga](https://redux-saga.js.org/) is Redux middleware that provides functionality for <Link to={"/articles/redux-side-effects"}>executing side-effects in a React-Redux app</Link>.
Essentially sagas are [function generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) which `yield` to middleware when a side-effect needs to run.

It isn't immediately obvious how to test this logic, especially if you don't often work with function generators.

## Example saga

Here's a toy saga that we'd like to test.

```typescript
// saga.ts
import { call, put, takeEvery } from "redux-saga/effects"
import { fetchUser, fetchUserAttributes, UserAttributes } from "./api"

/**
 * Redux actions
 */
export const fetchUserDataAction = { type: "fetchUserData" }
export const updateUserData = (payload: { name: string } & UserAttributes) => ({
  type: "fetchUserData",
  payload,
})

/**
 * Defines the business logic of fetching user data
 */
export function* fetchUserData() {
  // fetch data
  const { id, name } = yield call(fetchUser)
  const { immunities } = yield call(fetchUserAttributes, id)

  // dispatch synchronous redux action to update app state
  yield put(updateUserData({ name, immunities }))
}

/**
 * Link business logic to a specific redux action
 */
export function* fetchUserDataOnAction() {
  yield takeEvery(fetchUserDataAction.type, fetchUserData)
}
```

# Testing sagas directly

The concept of this approach is to directly invoke sagas in your tests.
This is the main approach that I've found when reading on how to test sagas online.

A way to approach this testing that I've found useful is to think about function generators as iterators for steps in a workflow.

```javascript
function* fetchData() {
  const step = num => console.log("ran step: " + num)
  yield step(1)
  yield step(2)
  yield step(3)
}

const iterator = fetchData()

iterator.next()
// => ran step 1
iterator.next()
// => ran step 2
iterator.next()
// => ran step 3
```

We can do something similar in our tests to step through behaviour and run assertions on our sagas.

```typescript
import { put } from "redux-saga/effects"
import { fetchUserData, updateUserData } from "./saga"

describe("fetchUserData", () => {
  it("calls APIs and updates state", () => {
    const iterator = fetchUserData()

    const name = "foo"
    const immunities = "bar"

    // should call /user
    iterator.next()
    const mockUserResponse = { id: "1234", name, immunities: undefined }

    // should call /userAttributes
    iterator.next(mockUserResponse)
    const mockUserAttributeResponse = {
      id: undefined,
      name: undefined,
      immunities,
    }

    const reduxAction = iterator.next(mockUserAttributeResponse).value // put redux action
    expect(reduxAction).toEqual(put(updateUserData({ name, immunities })))
  })
})
```

The main benefit of this approach is that you can running the saga logic "raw" in our tests, with minimal setup.

However, I have had difficulty using this practically in my day-to-day work primarily because we need to know the internals of the saga in order to write the test.
Specifically, we need to know the order in which the saga will `yield` and to prepare and pass the correct parameters to each call to `next`.
This makes the test brittle; if we change the order of yields or add new behaviour, we need to update our tests.

Another issue I have with this method is that we are invoking the saga differently to how we would in our actually code where we would be dispatching redux actions.

# Unit testing sagas

Ideally we should test our sagas according to their contract.
That means dispatching an action and validating that the saga results in the correct side-effects and changes to the store.

To allow this, we need some additional setup that takes away the need of manually invoking the saga and that allows us to dispatch actions.
Happily, all the needed functionality comes with `redux-saga` in the form of `channel`s and `runSaga`.

`runSaga` does what its name implies: it handles running a saga you give it.
A `channel` recieves and delivers Redux actions and can be passed to `runSaga`.
We can also provide a `dispatch` to `runSaga` which it will call when sagas dispatch actions to the store.
We can tie these three functionalities together in a test utility.

```typescript
import { Action } from "redux"
import { Saga, stdChannel, runSaga } from "redux-saga"

export const testRunSaga = <S extends Saga>(
  saga: S,
  ...params: Parameters<S>
) => {
  // channel to which events can be dispatched
  const channel = stdChannel()

  // a record of actions that the saga itself dispatches
  const dispatched: Action[] = []
  const dispatch = (action: Action) => dispatched.push(action)

  runSaga({ channel, dispatch }, saga, ...params)

  return { channel, dispatched }
}
```

Using this utility, we can write a test that allows us to test a saga as a unit.

```typescript
import * as api from "./api"
import {
  fetchUserDataAction,
  fetchUserDataOnAction,
  updateUserData,
} from "./saga"
import { testRunSaga } from "./testUtils"
import {} from "./testUtils"

const user: api.User = {
  name: "foo",
  id: "1234",
}
const userAttributes: api.UserAttributes = {
  immunities: "bar",
}

jest.spyOn(api, "fetchUser").mockImplementation(async () => user)
jest
  .spyOn(api, "fetchUserAttributes")
  .mockImplementation(async () => userAttributes)

describe("fetchUserDataOnAction", () => {
  it("should make expected calls and return data", async () => {
    const { channel, dispatched } = testRunSaga(fetchUserDataOnAction)

    channel.put(fetchUserDataAction)
    await new Promise(resolve => setTimeout(resolve)) // let async run

    const expectedPutAction = updateUserData({
      name: user.name,
      ...userAttributes,
    })
    expect(dispatched).toContainEqual(expectedPutAction)
  })
})
```
