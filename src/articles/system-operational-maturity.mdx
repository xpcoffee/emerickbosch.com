---
title: Operational capability roadmap
description: A method for analyzing operational capabilities of a system and determining next steps.
faIcon: faSeedling
date: 2022-03-23
tocDepth: 2
---

import { Link } from "gatsby"
import { Card } from "../components"

This document describes a method for thinking through operational capabilities of our systems to get a high-level understanding of where we can invest and what it would cost us.

# Problem

Investment into the operational capabilites of our systems is important to enable us to maintain our systems in a healthy state.
Despite the importance of this work, I've previously found it difficult to prioritise and track operational investment with respect to other work on our roadmap.

It would be useful to have a systematic approach with which to analyze our systems so that we can determine and prioritize the next operational investments of our systems.

# Glossary

- **operations** - the work needed to keep a system healthy while doing what _it is currently doing_ at _its current scale_.
- **scaling** - the work needed to enable the system to perform what _it is currently doing_ at _a larger scale_. For this we think big; 2x,5x,10x, or 100x the current load.
- **features** - the work needed to _add new capabilites_ to the system.

In this article we are specifically looking at **operations**.

I added definitions for scalability and features to clarify what operations is _not_.
Investments into both scalability and feature-work both require their own approaches, which are beyond the scope of this article.

<Card heading="Recommended reading">

This article also builds on terms and concepts introduced in <Link to="/articles/operational-observability">Operational Observability</Link>.
I recommend that you skim through that article before continuing.

</Card>

# Axes of operational investment

Before jumping into solution-mode I think it is useful to think about operations from first-principles
and come up with some explicit definitions for what we're trying to achieve by making these investments.

At its core, operating a system is the act of keeping its current state healthy.
To do this, we conceptually need 3 core abilities:

1. **Detecting problems**
1. **Diagnosing problems**
1. **Mitigating impact**

I've found that further breaking up detection and mitigation gives a decomposition that is more useful in practice.
This gives us 5 "axes" that we can invest in to make operations more effective, cheaper, more reliable and scalable:

1. **Detecting problems in production** - investing in this reduces our time to detection for issues that are actively affecting customers.
1. **Detecting problems before they reach production** - investing in this reduces the risk of releasing issues with new changes.
1. **Diagnosing issues in production** - investing in this reduces the time it takes to determine what an actual issue is.
1. **Mitigating impact by reverting to a previously-known stable state** - investing in this reduces the time it takes to mitigate an issue in production for issues that can be solved with a rollback.
1. **Mitigating impact by mutating the system** - investing in this reduces the time it takes to mitigate an issue in production for issues that require a fix/change to be deployed or applied to our system.

# Building and applying a capability roadmap

Armed with an understanding of our investment goals we now need to build a plan for how we can practically achieve them.
Here we'll call this plan a **capability roadmap**.

In these next sections, rather than try to build a one-size-fits-all roadmap, we'll lay out a general approach for building and using a capability roadmap.
We will then be able to use this approach for developing a roadmaps that make sense in the specific contexts of our systems.

## 1 Levels of capability

In practice, investments are easier to plan, prioritize, and execute if we do them iteratively.
If we want our roadmap to be practical, we need to plan out these potential iterations.

For each axis of operational investment, we will define levels/iterations which progressively improve our ability to operate on that axis.
Start with noting what the bare-minimum capability might look like for a new, non-critical version of our system.
Then note down what you think a web-scale, mission-critical version of our system would need.
Then think of what could be some major milestones that will take you from bare-minimum capability to web-scale.

When describing each level, focus on defining _what_ you want to do (not how to do it) and describe that capability _completely_ (these should not describe half-way points).

```yaml
# Example capability description
# ✔ good: describes a complete capability without describing how it's achieved
We can infer root causes from individual system events

# ❌ bad: does not describe a complete capability (pushing logs off hosts isn't useful by itself)
# and describes a technical solution (a log pushing system)
We have a system to push logs off of cloud hosts
```

Once we're done, we should have a set of levels/milestones for each axis.

```yaml
# Example
Axis: Diagnosing issues in production
Levels:
  1. Capability: We infer issues by noticing differences in external behaviour of our system
  2. Capability: We can filter and process key system events
  3. Capability: We can correlate changes in behaviour of multiple system events
  4. Capability: We have aggregations of current top causes of issues in our system
  5. Capability: We have a near-realtime, distributed trace of issues and key events in our system
```

## 3 Component breakdown

Now that we have milestones, we can focus on breaking these down into the 
high-level components that would need to be built to achieve this capability.

```yaml
# Example
Axis: Diagnosing issues in production
Levels:
    # ...
    2.  Capability: We can filter and process key system events
        Components:
            Event logs in our web service: system events written as log entries
            Log pusher system: logs pushed from service hosts to a central location
            Log dive system: ability to filter/search logs pushed from our hosts
            Runbook: a reference of how to identify common issues from our logs
    # ...
```

With levels of capability and the components needed to reach them, we now have 
an overview for how we can invest in the operational capabilities of our systems.

Note that at this point, our levels and capabilities aren't very specific to any one system.
The next step is to analyze an individual system to see where it lies along our different axes.

## 4 Analyze a specific system

For each axis and capability, analyze what components already exist in our system
to determine what our _current_ level of capability is. 
We can then use our roadmap to identify the components we need to build to take us to the _next_ level.

<Card heading="Example">

For "Diagnosing issues in production", let's imagine we have a system that currently meets 
all the criteria for Level 1, and that we already log key events to log files on our servers.

To take our system to Level 2, we'd need to do work to:

1. push our logs from our servers to a central point of storage
2. build some tooling that allows us to search through our storage logs 
3. document how to diagnose the most common issues using logs in a runbook

</Card>

Now is also a good point at which to make some estimates of the work needed to implement/integrate these missing components.

Once done with estimations we should be in a position where we have 
a clear idea of components we could build, what they would cost us to build, 
and an understanding of what reaching the next level will give us.

## 5 Cost vs benefit and prioritization

We have all the pieces of information we need to have a productive discussion about cost vs. benefit of investing along our different axes.
This cost/benefit should also give us a good sense of which axis we want to invest in first, 
as well as how to prioritize this work against other tasks the team needs to accomplish.

# Deep example: Web-service capability roadmap

## Detecting problems in production

Investing in this axis reduces the time and effort needed to detect issues.
 
![](./images/operational-capability-detecting-problems-in-production.jpg)

```yaml
Axis: Detecting problems in production
Levels:
    1.  Capability: >
            We compare actual behaviour against documented behaviour to infer system 
            health.
        Components:
            - Documentation of healthy system behaviour
            - Runbook for common error senarios
    2.  Capability: >
            We infer system health by looking at the behaviour of diagnostic events 
            emitted by the system.
        Components:
            - System logs for key events
            - Ability to dive into logs
            - Diagnostic metrics pushed by the system
            - Dashboard for diagnostic metrics
    3.  Capability: >
            We determine system health through dedicated system health signals.
        Components:
            - Health signals
            - Health dashboard with overview of health signals
    4.  Capability: >
            We automatically alarm and roll back recent changes using health signals.
        Components:
            - automatic alerts linked to health signals
            - communication channel in which to publish alerts
```

## Detecting problems before production

Investing in this axis improves our confidence that changes will not cause regression in our existing behaviour.

There can be two types of impact from new changes, which we want to catch:

- **availability** - when a change causes errors/crashes in the system or degrades the performance to where it affects usability
- **semantic** - when a change causes incorrect behaviour without affecting the availablity of the system

Availability regressions can be caught before they reach production using staging/pre-prod environments on which we monitor system health.

Semantic regressions are more complicated to catch; the majority of these levels of investment address this style of problem.

![](./images/operational-capability-detecting-problems-before-production.jpg)

```yaml
Axis: Detecting problems before production
Levels:
    1.  Capability: >
            We test our implementations against explicit definitions of correct 
            semantic behaviour.
        Components:
            - explicit definitions of correct behaviour for each change
    2.  Capability: >
            We have review processes for our designs and implementations.
        Components:
            - code review process
            - design review process
            - security review process
            - UX/usability review process
    3.  Capability: >
            We have regression tests in our implementations for correct semantic 
            behaviour.
        Components:
            - unit tests
            - regression tests
    4.  Capability: >
            We have a pre-production version of our system that we deploy and test 
            new changes in.
        Components:
            - pre-prod environment in deployment pipeline before production deployments
    5.  Capability: >
            We have automated testing of availability in pre-production
        Components:
            - health signals in pre-production that match those in production
            - integration tests running on pre-production before deployment to production
    6.  Capability: >
            We have automated testing of correct semantic behaviour in pre-production.
        Components:
            - end-to-end tests running on pre-production before deployment to production
```

## Diagnosing issues in production

![](./images/operational-capability-diagnose-problems-in-production.jpg)

```yaml
Axis: Diagnosing issues in production
Levels:
    1.  Capability: >
            We infer issues by noticing differences in external behaviour of our system
        Components:
            - Runbook of how to diagnose common errors from external system behvaviour
    2.  Capability: >
            We can filter and process key system events
        Components:
            - System logs for key events
            - Ability to dive into logs
            - Runbook of how to diagnose common errors from system logs
    3.  Capability: >
            We can correlate changes in behaviour of multiple system events
        Components:
            - Diagnostic metrics
            - Diagnostic metric dashboard
            - Runbook of how to diagnose common errors from diagnostic metrics
    4.  Capability: >
            We have aggregations of current top causes of issues in our system
        Components:
            - Diagnostic metric aggregations (historograms/percentiles)
            - Pre-prepared queries that show top causes of errors in the system
    5.  Capability: >
            We can track requests through our system in near-realtime
        Components:
            - Distributed tracing integrated throughout system
            - Tooling for querying/filtering distributed traces in near-realtime
```


## Mitigating issues by reverting to previous stable state

![](./images/operational-capability-mitigation-via-reverting.jpg)

```yaml
Axis: Mitigating issues by reverting to previous stable state
Levels:
    1.  Capability: >
            We have previous versions of state that we use to manually roll back
        Components:
            - Regular versioning/backups of code and system state
            - Runbook for how to roll back to a backed-up version of production code/state
    2.  Capability: >
            We programmatically run revert/restore actions
        Components:
            - Scripts that can execute common backup/restore/revert actions
    3.  Capability: > 
            We automatically roll back impactful changes when degredation is detected
        Components:
            - System health signals
            - Ability to detect if a change was deployed recently
            - Ability to trigger a rollback action from a health signal
```


## Mitigating issues by mutating production

![](./images/operational-capability-mitigation-via-mutation.jpg)

```yaml
Axis: Mitigating issues by mutating production
Levels:
    1.  Capability: >
            We run mutating actions manually against production
        Components:
            - Runbooks for how production can be mutated
    2.  Capability: >
            We have a processes to guide us through safely mutating production
        Components:
            - Process for determining when we can manually mutate production
            - Scripts for common or high-risk mutating actions
            - Runbooks for when/how to run scripts against production
    3.  Capability: >
            We have dedicated tooling for making changes to production
        Components:
            - WebUI or CLI that exposes possible mutating actions against production
            - Audits that tracks when changes are made and by whom
    4.  Capability: >
            We have contextual validation of mutating actions
        Components:
            - Tooling is aware of system health
            - Tooling raises warnings/adds friction for particularly risky operations
```

# Conclusion

Building and applying an operational capability roadmap can give us a holistic view of what operational investments we can make to our systems.
By defining capabilities and by breaking down the components we need to attain those capabilities, 
we gain an understanding of the cost vs benefit of these investments. 
We can then take an informed decision about whether or not to invest further and, if we do, where to prioritize these further investements.
