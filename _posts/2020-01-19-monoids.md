---
layout: post
title: "Monoids"
summary: An intuition-first look at a mathematical way to guarantee composability.
tags: [mathematics, pattern, software architecture]
permalink: monoids
---

Composition is a core topic when dealing with complex systems. In this document we'll briefly go through why we should care about composition and how we can use the mathematical concept of a monoid to help us design and build systems that enable composition.

## Composition

The human mind is not infinite; there's a limit to the complexity of ideas that one can think about. This limit is also different between individuals. These limits affect our ability to build systems that can solve complex problems: if you can't conceptualize the problem in its entirety, how do we design, build and maintain these systems? The answer is to break up the problem into multiple smaller problems, solve those individually and then compose the individual solutions into a complete solution.

Composition is the central, most important problem-solving tool we have available to us and is employed in every aspect of our lives: machines are composed of parts, which are themselves composed of individual structures, joints, and fasteners; paintings are composed of individual brush-strokes, each of which applies a single spot of colour; symphonies are a composition (literally) of individual notes and tones that are made by individual instruments; companies are composed of business units, each with its specialty and which are themselves composed of individuals which can deliver different skillsets; etc.

In practice, there are multiple ways to arrive at a successful composition: through trial and error or by emulating systems that exist elsewhere e.g. nature. It is also possible to get there by defining a set of rules that, when followed, guarantee composition. This approach one that's heavily used in standards e.g. if I define a standard shipping container as a composable unit, then people can focus on storing their goods in their own container without caring about what is in containers they don't own, and all the individual container units can be composed together to make up the full cargo for a shipping vessel.

This approach to "design" composability by setting up rules is what we'll look at in this discussion. In particular, one approach allows us to _mathematically guarantee_ composition in a way that's useful to use when programming: monoids.

## Monoids

"Monoid" is the term that we give to a grouping of items that can be composed _and_ the operation that you can use to compose them. Both the items and the operation also need to follow a specific set of rules. This sets up a mathematical system that we can practically use. What I want to do here is to help you build up an intuition around the rules and the properties of monoids that make them useful. We'll do this one step at a time using the help of some LEGO bricks.

> Disclaimer: Please note that LEGO® is a trademark of the LEGO Group of companies which does not sponsor, authorize or endorse this site. I'm using LEGO bricks here mainly to help build up an intuition around the subject using a toy that many readers are likely to be familiar with.

So, we have a set of items that we want to compose together:

![](/assets/so-you-want-to-compose.png)

To start with, we need some operation that can compose two elements. For this discussion, we'll say that our operation takes two blocks and clips the first block on top of the second block. This operation is called **the monoidal product** and we can use the symbol **⊗** to help us write down what we're doing e.g. `A ⊗ B = C`

![](/assets/monoidal-product.png)

Take a look at the items themselves. Notice how the LEGO blocks share attributes that allow them to be composed together: they have studs on the top and a structure on the bottom that can clip onto studs. To phrase it slightly differently, these specific LEGO bricks are part of the larger <span class="tooltip" data-tooltip="A set is the mathematical term for a group of items that share properties.">**set**</span> of LEGO blocks that have studs at the top and the ability to clip onto studs at the bottom.

Now take a look at the result `C`. It too is part of the set: it has studs at the top and could also clip to studs at the bottom. This is really important: the resulting item of our operation (which takes two items in a set) is also an item in the set. Because it's in the set, we could also perform our operation on this result to get further composition. This property conceptually allows us to keep composing items together infinitely.

![](/assets/further-composed.png)

<small>First condition for a monoid: we need a **monoidal product** that **takes two items in a set** and **returns an item in the same set**.</small>

We now have the core of a system that allows composability, but we need to define some more rules that help make this system easy to work with.

The first of these is that we want to be able to perform compositions in any order. The picture below shows how two different composition orders for `A ⊗ B ⊗ C ⊗ D` result in the same end composition.

![](/assets/associativity.png)

Why is this a useful property to have in our system? It allows us to break up work. For example: if you have multiple people helping you build `(A ⊗ B) ⊗ (C ⊗ D)`, you can have person 1 do `(A ⊗ B)`, person 2 can do `(C ⊗ D)` and person 3 can take the results from person 1 and person 2 and compose them together into the final result. This is the key principle behind assembly lines in factories and parallel processing in software systems. This property of not caring for which operation is performed first is called **associativity**.

An important note here that the "position" of the items still makes a difference: `A ⊗ B` is not the same as `B ⊗ A`. The above is about the order in which you perform the monoidal product.

![](/assets/ab-not-ba.png)

<small>Second condition for a monoid: the monoidal product must be **associative**.</small>

The last thing we need to consider is that what we're building is a mathematical system. Mathematical systems, both in pure-maths and when part of software systems, don't know the exact data/information they will be working with ahead of time. In the case of composability, we won't know the number of items we'll need to compose together ahead of time. So our system needs to be able to handle any number of items. How do we handle the case where we're given _a single item_ given that we've built a system on top of the monoidal product, which composes _two_ items together?

Here's where our example with LEGO blocks breaks down a bit. In real life, if we're given a single block we know that we don't need to do anything; there's nothing to attach that block to so we don't even try to apply the operation. In many situations - software processes in particular - we don't get to make that choice: we _have_ to run the operation every time the system is given something. The mathematical solution around this is rather sneaky and seems almost petty. We just _invent_ an item in the set (we can do this; maths is all in your head) and we _define it_ so that it doesn't do anything if it is used in the monoidal product. We call this item the **identity** and I'll use the symbol `i` for simplicity here (though `e` is often used as the symbol most often). With the identity we have `A ⊗ i = A` and `i ⊗ A = A`.

Here are some examples of identities in mathematical systems that you've seen before:

-   In arithmetic if we take the operation `+`, 0 is our identity: `4 + 0 = 4` and `0 + 4 = 4`
-   In arithmetic if we take the operation `*`, 1 is our identity: `7 * 1 = 7` and `1 * 7 = 7`

The identity also helps us deal with another case: the one where we're asked to compose an empty list of items. In this case, we can fall back to running the operation on two identities: `i ⊗ i = i`

<small>Third condition for a monoid: the set we're using in our monoid must have an **identity** which, when used with another item in the monoidal product will result in the other item.</small>

And that's it. We have three conditions that give us a mathematical system that we can use and which mathematically guarantees composition:

1. There is a **monoidal product** that **takes two items of a set** and **returns an item in the same set**.
2. The monoidal product must be **associative**.
3. There is an **identity** in the set which, when used with another item in the monoidal product, will result in the other item.

So what do monoids look like in practice? Ironically, our LEGO blocks are not a monoid: we saw that this system doesn't have an identity, so it would run into issues if we used it as a purely mathematical system. There are several monoids in arithmetics: the set of real numbers, the monoidal product `+` and the identity `0` form a monoid; the set of real numbers, the monoidal product `*` and the identity `1` also form a monoid. We can also design them when writing software.

## Example monoid in code

Let's design a monoid that allows us to combine wishlists of stuff that our loved ones want.

```javascript
/**
 * We define a set of items with similar attributes that we want to compose:
 *
 * @typedef { { type: "normal" | "identity"; totalCost: number; items: string[]; } } Wishlist
 *
 * Note that we've given us a way to determine the identity as part of this set.
 */

/**
 * Convenience function for the identity
 * @returns {Wishlist} the identity
 */
function getIdentity() {
    return { type: "identity", totalCost: 0, items: [] };
}

/**
 * Our monoidal product
 * @param {Wishlist} wishlistA
 * @param {Wishlist} wishlistB
 */
function combineWishlists(wishlistA, wishlistB) {
    // We force our identity to have no effect
    if (wishlistA.type === "identity") {
        return { ...wishlistB };
    }

    if (wishlistB.type === "identity") {
        return { ...wishlistA };
    }

    return {
        type: "normal",
        totalCost: wishlistA.totalCost + wishlistB.totalCost,
        items: [...wishlistA.items, ...wishlistB.items],
    };
}

// We then write some tests that will ensure that this is actually a monoid
const assert = require("assert");

(function testAssociativity() {
    const wishlistA = { type: "normal", totalCost: 10, items: ["foo", "bar"] };
    const wishlistB = { type: "normal", totalCost: 200, items: ["baz"] };
    const wishlistC = { type: "normal", totalCost: 15, items: ["qux", "bar"] };

    // test (A x B) x C is the same as A x (B x C)
    const resultA = combineWishlists(wishlistA, combineWishlists(wishlistB, wishlistC));
    const resultB = combineWishlists(combineWishlists(wishlistA, wishlistB), wishlistC);
    assert.deepStrictEqual(resultA, resultB, "The monoidal product is not associative.");

    // sanity check for the actual values (should likely be tested in its own tests)
    assert.deepStrictEqual({ type: "normal", totalCost: 225, items: ["foo", "bar", "baz", "qux", "bar"] }, resultA);
})();

(function testIdentity() {
    const wishlistA = { type: "normal", totalCost: 10, items: ["foo", "bar"] };

    const oneWay = combineWishlists(wishlistA, getIdentity());
    assert.deepStrictEqual(
        oneWay,
        wishlistA,
        "The monoidal product with the identity in the second argument does not return the first argument"
    );

    const otherWay = combineWishlists(getIdentity(), wishlistA);
    assert.deepStrictEqual(
        otherWay,
        wishlistA,
        "The monoidal product with the identity in the first argument does not return the second argument"
    );

    const identities = combineWishlists(getIdentity(), getIdentity());
    assert.deepStrictEqual(
        identities,
        getIdentity(),
        "The monoidal product on identities does not result in an identity"
    );
})();
```

Now that we've defined our monoid, let's use it.

```javascript
const wishlistDad = {
    type: "normal",
    totalCost: 100,
    items: ["Running shoes"],
};

const wishlistBro = {
    type: "normal",
    totalCost: 300,
    items: ["Concert tickets", "Video game subscription"],
};

/**
 * @type {Wishlist[]}
 */
const individualLists = [wishlistDad, wishlistBro];

/**
 * Compose all the wishlists together using reduce.
 *
 * Step by step:
 *
 * identity x wishlistDad => compositionStep1
 * compositionStep1 x wishlistBro => compositionStep2
 */
const familyWishlist = individualLists.reduce(combineWishlists, getIdentity());
console.log(familyWishlist);

// Output:
// {
//   type: 'normal',
//   totalCost: 400,
//   items: [ 'Running shoes', 'Concert tickets', 'Video game subscription' ]
// }

const friendsWishlist = {
    type: "normal",
    totalCost: 25,
    items: ["Sci-fi novel"],
};

// The previous result can continue to be composed with new wishlists
const finalWishlist = combineWishlists(familyWishlist, friendsWishlist);
console.log(finalWishlist);

// Output:
// {
//   type: 'normal',
//   totalCost: 425,
//   items: [
//     'Running shoes',
//     'Concert tickets',
//     'Video game subscription',
//     'Sci-fi novel'
//   ]
// }
```

So there you have it. Monoids: one way of designing a system that guarantees composability.
